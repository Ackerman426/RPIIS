# Лабораторная работа 5
 
### Цель: 
 
Освоить командные оболочки shell (для OS семейства Unix) и cmd (для OS семейства MS Windows):
+ изучить основные встроенные команды,
+ научиться писать файлы сценариев,
+ научиться соотносить командные оболочки для разных OS.
+ Освоить командное окружение для OS семейства Unix(утилиты из пакета GNU Core Utilities), и соответствующие им утилиты для OS семейства MS Windows.
### Условия задания
38 Создать файл sh и bat, который выполняет следующее: 
На вход пакетному файлу приходит путь к каталогу (как параметр пакетного файла). В указанном каталоге создаем структуру каталогов следующим образом: активные процессы в ОС группируются по названию и название присваивается вновь созданному каталогу, далее внутри каталога создаются файлы с номерами PID сгруппированных процессов, в файл записывается размер используемой памяти.
## Batch файл
- ### Код программы :computer:
```batch
@echo off
 chcp 65001 > nul  

setlocal enabledelayedexpansion
set TARGET_DIR=%1

:: проверка подкл папки
if "%TARGET_DIR%"=="" exit /b

::создаем папки и в них текстовые и пишем память в файл
for /f "skip=3 tokens=1,2,5 delims=," %%A in ('tasklist /fo csv /nh') do (
    mkdir "%TARGET_DIR%\%%~A" 2>nul 
:: переменная для мемори
    set "mem=%%C"
    echo !mem! > "%TARGET_DIR%\%%~A\%%~B.txt"
)
```
## Пример работы кода
![Снимок экрана 2024-11-18 111330](https://github.com/user-attachments/assets/e590bf1b-cfef-44d1-b894-2029de9e6b43)

![Снимок экрана 2024-11-18 111214](https://github.com/user-attachments/assets/93b771ea-135a-4fed-befb-ed144ab9ede4)
### Пояснение кода
Отключает вывод команд в командной строке, что делает вывод более чистым и удобным для пользователя.
```
@echo off
```
Устанавливает кодировку UTF-8, чтобы корректно отображать кириллические символы.
```
chcp 65001
```
Создаем папки, используя переменные. Токены отвечают за 1,2 и 5 столбец команды tasklist. Переменнным A, B и C присвоены значения столбцов соответственно.
```
for /f "skip=3 tokens=1,2,5 delims=," %%A in ('tasklist /fo csv /nh') do (
    mkdir "%TARGET_DIR%\%%~A" 2>nul
```
Создаем файлы и одновременно записываем в них значение памяти с помощью mem(memory).
```
echo !mem! > "%TARGET_DIR%\%%~A\%%~B.txt"
```
## Bash файл
- ### Код программы :computer:
```bash
#!/bin/bash 

# проверяем подкл папки
if [ -z "$1" ]; then
    echo "Please specify the target directory."
    exit 1
fi
# сохр путь в переменну таргет
TARGET_DIR="$1"


# ps 
ps aux | tail -n +2 | while read user pid cpu mem time tty status command; do
    #  извлекает имя команды из полного пути
    process_name=$(basename "$command")
    
  
    # создание подпапок
    process_dir="$TARGET_DIR/$process_name"
    mkdir -p "$process_dir"
    
    # создание файлов 
    file_path="$process_dir/$pid.txt" 
#если файл сущ
    if [ ! -f "$file_path" ]; then 
        # пишем память
        echo "$mem KB" > "$file_path"
    fi
done
```
## Пример работы кода
![Снимок экрана 2024-11-18 113145](https://github.com/user-attachments/assets/b3595e8e-50eb-4667-a0df-7ad52252453d)
![Снимок экрана 2024-11-18 113201](https://github.com/user-attachments/assets/a0611819-8835-432a-9d3a-1ac0916c9400)
### Пояснение кода
Указывает, что скрипт должен выполняться с использованием интерпретатора bash.
```
#!/bin/bash
```
Скрипт проверяет, передан ли аргумент (целевой каталог). Если нет, выводится сообщение и скрипт завершает работу.
```
if [ -z "$1" ]; then
    echo "Please specify the target directory."
    exit 1
```
Выводим информацию о всех запущенных процессах. tail -n +2 пропускает первую строку заголовка.Для каждого процесса извлекаются его данные, такие как пользователь, PID, использование CPU, память и команда.
```
ps aux | tail -n +2 | while read user pid cpu mem time tty status command; do
```
Создание папок с помощью  mkdir.
```
 process_dir="$TARGET_DIR/$process_name"
    mkdir -p "$process_dir"
```
Создание файлов
```
file_path="$process_dir/$pid.txt" 
```
Записываем в файл память
```
echo "$mem KB" > "$file_path"
```

### Выводы: 
 В ходе выполнения лабораторной работы по освоению командных оболочек cmd (для операционных систем семейства MS Windows) и shell (для операционных систем семейства Unix) были получены практические навыки работы с консольными программами и командами в различных операционных системах. 
